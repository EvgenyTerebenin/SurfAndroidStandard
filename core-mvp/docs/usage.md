# Использование

Данный модуль обеспечивает работу **UI слоя**.

Слой представления можно разбить на следующие под-слои:
* слой Presenter;
* слой View;


#### Presenter

**TODO**: проверить актуальность

Основной частью этого слоя являются презентеры экранов,
содержащие всю логику соответствующего экрана.
Все презентеры должны быть унаследованы от класса **BasePresenter**.

Презентеры не уничтожаются при изменении конфигурации.
Этот механизм реализован с помощью сохранения всего Dagger-компонента
экрана и переиспользования его для воссозданного View.
Презентер уничтожается при полном уничтожении экрана (например после `Activity#finish()`).

Для оповещения вью об изменения состояния используется одна модель extends ScreenModel),
которая передается в метод вью `#render()`. Модель при отрисовке должна
полностью переводить вью в необходимое состояние,
никакой другой механизм для изменения состояния вью использовать запрещено.
Разовое отображение SnackBar и другие разовые действия не относятся к состоянию.
Предусмотрены базовые классы ScreenModel,
поддерживающие различные состояния, например LoadState (состояние плейсхолдера).
Работают в связке с соответствующим базовым классом Вью.

Если какое либо конкретная часть состояния вью выводится из данных ScreenModel,
то метод вывода этого состояния должен быть в ScreenModel,
например: ScreenModel содержит модель корзины, которая в свою очередь
содержит информацию об акциях.
Если в зависимости от наличия акций необходимо показывать на UI блок с акциями,
то ScreenModel должен содержать метод `boolean shouldRenderActions()`,
в котором будет проверка акций.
Или если другими словами, **оставляем во вью как можно меньше логики,
чтобы потом можно было протестировать ее Unit тестами**.


Когда View становится готовой к работе, у презентера вызывается метод #onLoad().
Возможны 2 сценария для метода #onLoad():
- Первый запуск экрана - следует начать загрузку данных;
- Данные экрана загружены или загружаются - следует показать текущее состояние(ScreenModel) на View;

**Presenter может взаимодействовать с асинхронными задачами только через Rx**.
Для подписки на асинхронную задачу следует вызвать один из методов презентера `#subscribe()`.
Подписка, созданная таким образом, обладает следующими свойствами:
- Происходит заморозка Rx событий (onNext, onError, onComplete)
перед уничтожением View и разморозка после ее воссоздания.
Это свойство необходимо для предотвращении обработки событий,
когда Presenter не имеет ссылки на View.
- Происходит заморозка Rx событий на `#onPause` и разморозка на `#onResume`.
Это свойство позволяет предотвращать обработку событий невидимыми экранами
(например, когда экран находится в стеке).
- Происходит отписка всех Rx подписок при полном уничтожении экрана.

Передача в Presenter аргумента переданного в Intent или Bundle
при старте экрана должна производиться через Dagger.

Для сетевых запросов в презентере предусмотрены методы `#subscribeIoHandleError()`,
содержащие стандартный обработчик ошибок сетевых запросов.

Все варианты методов #subscribe() перед подпиской переводят Observable в mainThread (.observeOn(...)).
Кроме того, все варианты методов `#subscribeIoHandleError()`
производят подписку на Observable в рабочем потоке (.subscribeOn(...)).

Для объединения запросов к репозиториям необходимо использовать
ObservableUtil#combineLatestDelayError() вместо Observable#zip().
Это продиктовано особенностью получения данных.
Каждый Observable может эмитить 2 элемента: один из кеша, другой с сервера.
Observables в этом случае выполняются параллельно.
Также к слою Presenter относятся классы с логикой UI части приложения,
такие как Navigator.
Эти классы также поставляются Dagger и не должны иметь прямую ссылку на Activity,
View и другие части, которые могут стать невалидными при смене конфигурации.
Однако для доступа к функционалу этих частей можно использовать классы FragmentProvider и
ActivityProvider, которые поставляют валидные Fragment и Activity при каждом вызове #get().

Api презентера может иметь только методы вида **`void someMethod(params...)`**,
это необходимо для соответствия принципу **unidirection data flow**

![](images/unidirect-dataflow.png)


#### View

**TODO**: многое уже не актуально

Слой View является максимально пассивным и выполняет 2 задачи:
- Показывает информацию пользователю;
- Передает события пользовательского ввода в Presenter.

Для создания View экрана следует наследоваться от одного из классов:
Base(Core)Activity...View или Base(Core)Fragment...View.
см типы базовых классов вью

Если какая-то область экрана (View) является логически связанной,
то следует обернуть ее в кастомную android.ViewGroup,
даже если она не будет переиспользоваться на других экранах.
Взаимодействие частей View (например Adapter, кастомная android.View)
напрямую с презентером запрещено.
Только View может взаимодействовать с презентером. -> Widgets!!!!!

**Ниже исправить - уже по-другому.**

Также есть возможность использовать презентеры в кастомных android.View,
для этого следует заинжектить этот презентере в базовую вью
(Activity или Fragment реализующие интерфейс PresenterHolderCoreView)
и переопределить метод bindPresenters,
в котором связать кастомную android.View с презентером

Если экран не содержит логики, то следует наследоваться от BaseActivity или BaseFragment.
У базовых классов View есть методы runDelayed(),
которые работают также как и Handler#postDelayed(). - **точно есть - нет такого**

Api вью может иметь только методы вида void someMethod(params...),
это нужно для соответствия принципу Unidirectional data flow.

##### Базовые классы и интерфейсы вью
Классы указаны в порядке наследования.
* CoreActivityView - Класс с корневой логикой вью
* BaseHandleableErrorActivityView - базовый класс для ActivityView,
поддерживающий обработку ошибок
* BaseRenderableHandleableErrorActivityView - базовый класс для ActivityView,
поддерживающий отрисовку ScreenModel и обработку ошибок

* BaseLdsActivityView - базовый класс ActivityView c поддержкой
состояния загрузки {@link LoadState}
Используется вместе с PlaceHolderView.

Если на экране производится запрос, в течении которого нельзя давать
пользователю взаимодействовать с контентом - используем LoadState.LOADING_TRANSPARENT.
Если при этом запрос не очень важный, лучше блокировать только необходимую часть контента,
при этом демонстрировать PullToRefresh или другой индикатор и скрывать его
при снятии блокировки с UI.

* BaseLdsSwrActivityView
базовый класс ActivityView c поддержкой:
   * состояния загрузки {@link LoadState}
   * состояния SwipeRefresh {@link SwipeRefreshState}
Этот базовый класс можно не использовать если с большой гарантией можно
предвидеть что пользователю не потребуется обновлять контент

* BaseLdsSwrPgnActivityView
базовый класс ActivityView c поддержкой:
   * состояния загрузки {@link LoadState}
   * состояния SwipeRefresh {@link SwipeRefreshState}
   * состояния пагинации {@link PaginationState}
   * обновления списка - реализует интерфейс {@link ChangeableListView}
Работает в связке с PaginationableAdapter (базовый адаптер с пагинацией, имеет готовый футер с 3-мя состояниями: загружается, ошибка при загрузке, невидимый(достигли конца списка);

Для Фрагмента предусмотрены аналогичные базовые классы
* Интерфейсы
   * CoreView -базовый интерфейс для всех вью, может быть использован
для кастомных android.View c поддержкой презентера.

Остальные интерфейсы уже использованы для базовых классов вью.
