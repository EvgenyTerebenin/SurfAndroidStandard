[TOC]

# Слой Interactor

**Interactor** - содержит внутреннюю(бизнес) логику приложения.
Этот слой предоставляет доступ к хранилищам данных и другим сервисам.
Api этого слоя не должно зависеть от Android Framework и других библиотек.
Слой Interactor состоит из модулей, каждый из которых имеет строго определенную
ответственность. Детали реализации каждого модуля не должны быть доступны
никаким другим частям приложения, кроме этого модуля. На этом уровне должно
происходить трансформирование структур данных, используемых во внешних хранилищах,
в модели слоя Domain. Бизнес логика должна быть максимально отделена от
деталей реализации.

### Механизм ошибок

Обработка большинства ошибок [происходит на UI слое][handle_errors].
Для этого предусмотрен ErrorHandler,
стандартная его имплементация находится в базовой вью экрана и
используется в методе `BasePresenter`.

### Рассылка событий через Interactor

Еще один кейс использования интеракторов: построение событийной модели общения
между частями приложения.

Например, некоторое действие на активити А должно вызывать обновление
данных на активити Б. Причем, данное действие не является результатом активити А.
Тогда можно пробросить событие через общий интерактор у данных активити.
Данный кейс, показывает, что приоритетнее использовать именно интерактор для
обновления данных, а не результат активити(например через `RouteWithParams`).
Маршрут с параметрами сдледует использовать там, где очевиден возврат результата, например,
некая форма, которая возвращает заполненные данные на предыдущий экран.

Реализовать проброс этого события можно через создания `Subject'а` внутри
инетрактора. При этом этот Subject должен быть приватным, а наружу должен
смотреть только соответствующий `Observable`.

``` kotlin
private val someEventSubject = PublishSubject.create<SomeEvent>()
val observeSomeEvent: Observable<SomeEvent> = someEventSubject
```

*Примечание*: выбор типа сабжекта зависит от нужд приложения.

Только там интерактор может эмитить события - презентер может лишь менять данные,
но не напрямую рассылать сообщения.

Может возникнуть кейс, когда экран, который вызывает изменение данных, сам
подписан на изменение. Тогда следует добавить в чейн с подпиской оператор filter.
``` kotlin
    someDisposable = subscribe( interactor.observeSomeEvent
            .filter { someDisposable.isDisposed },
        {
            // OnSuccess
        })
```

Таким образом, можно офильтровать событие, чтобы оно не хендлилось на текущем экране.

[handle_errors]: ../ui/presenter.md