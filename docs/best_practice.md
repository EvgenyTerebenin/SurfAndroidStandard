# Лучшие практики

[][TODO: тут пока текст , который еще не вставили в конкретное место]


## Общие сведения

Архитектура построена на упрощённой версии **СleanArchitecture**,
адаптированной под мультимодульную архитектуру.

Основной причиной для выбора описанной архитектуры было стремление
уменьшить сложность проекта. В частности использовались 2 основных принципа:

- Принцип единственной ответственности (разделение на слои, модули)
- Инкапсуляция (сокрытие реализации от остальных частей приложения)


*Приложение состоит из следующих основных слоев*:

* Domain - содержит сущности и логику предметной области.
* Interactor - содержит внутреннюю(бизнес) логику приложения.
Этот слой предоставляет доступ к хранилищам данных и другим сервисам.
Api этого слоя не должно зависеть от Android Framework и других библиотек.
Слой Interactor состоит из модулей, каждый из которых имеет строго определенную
ответственность. Детали реализации каждого модуля не должны быть доступны
никаким другим частям приложения, кроме этого модуля. На этом уровне должно
происходить трансформирование структур данных, используемых во внешних хранилищах,
в модели слоя Domain. Бизнес логика должна быть максимально отделена от
деталей реализации.
* UI - содержит логику пользовательского интерфейса
  * Presenter - содержит логику экранов. В презентере происходят все манипуляции
  с данными, изменение данных внутри View недопустимо. Презентеры не должны
  содержать бизнес логику приложения.
  * View - слой представления, отвечает за взаимодействие с пользователем.
  Вью не должна содержать логику экрана, только логику отображения. Вью должна
  быть максимально пассивной.


Каждый последующий слой может зависеть только от предыдущего и от слоя Domain.
Каждый класс принадлежит только одному из вышеперечисленных слоев.

## presenter

Для объединения запросов к репозиториям необходимо использовать
ObservableUtil#combineLatestDelayError() вместо Observable#zip().
Это продиктовано особенностью получения данных.
Каждый Observable может эмитить 2 элемента: один из кеша, другой с сервера.
Observables в этом случае выполняются параллельно.

## ui

Если на экране производится запрос, в течении которого нельзя давать
пользователю взаимодействовать с контентом - используем LoadState.LOADING_TRANSPARENT.
Если при этом запрос не очень важный, лучше блокировать только необходимую часть контента,
при этом демонстрировать PullToRefresh или другой индикатор и скрывать его
при снятии блокировки с UI.


## Interactor

Еще один кейс использования интеракторов: построение событийной модели общения между частями приложения.
Например, некоторое действие на активити А должно вызывать обновление данных на активити Б.
Причем, данное действие не является результатом активити А.
Тогда можно пробросить событие через общий интерактор у данных активити.

## Пагинация

todo

Предусмотрены два модуля datalist-limit-offset и datalist-page-count,
которые предоставляют списки, предназначеные для пагинации.
Также существует BasePaginationableAdapter, расширение которого реализует адаптер для пагинации.