# UI слой

Ядром UI-слоя является модуль [core-ui][core-ui].

Большинство наших приложений построено на MVP-архитектуре.
Слои View и Presenter принадлежат к UI. Для реализации MVP используется
надстройка над core-ui в виде [core-mvp][core-mvp].


#### Структура пакетов

Так как используется многомодульная архитектура, то данный слой представлен несколькими модулями:
* app-injector - содержит конфигураторы экранов(Dagger)

* base-ui - включает базовые классы данного слоя для всех фич, а также переиспользуемые сущности,
которые нельзя выделить в отдельную фичу или же это не имеет смысла(Например конкретная кастомная вью без презентера и дополнительных сущностей)
Также включает в себя пакет util, который содержит в себе полезные сущности, хелперы, методы для работы с UI.
Может включать в себя пакет navigation для навигации между модулями.

* f-*name* - конкретный модуль фичи(см. [Многомодульность](common_info.md))
Может быть разбит по более мелким пакетам - логическим кускам фичи(конкретным экранам , относящимся к одной фиче).
Содержит классы Route, View, Presenter, ScreenModel, Controller, etc


#### Иcпользование студийных модулей
Для построения ахитектуры UI слоя следует подключить в проект core-модули:
- [core-ui](../core-ui/README.md)  - базовые классы ui-слоя
- [core-mvp](../core-mvp/README.md)- mvp-обертка для core-ui
- [core-app](../core-app/README.md) - стандартная конфигурация App + дополнительные сущности

Также при неодбходимости использовать диалоги с поддержкой mvp и виджеты:
- [mvp-dialog](../mvp-dialog/README.md) - стандартные диалоги
- [mvp-widget](../mvp-widget/README.md) - виджеты с поддержкой mvp

Опционально(**экспериметальный модуль**):
- [core-mvp-binding](../core-mvp-binding/README.md) - модуль для биндинга

Как правильно построить UI слой можно посмотреть [здесь](../core-mvp/docs/usage.md).

##### Создание экрана
Для создания экрана необходимо проделать следующие шаги:
1. Расширить 4 класса ..Route, BasePresenter, ..View, , ..ScreenModel
1. Расширить ScreenConfigurator в app-injector'е и занести его в ScreenConfiguratorStorage;

При наследовании от одной из базовых View следует имплементировать следующие методы:
* #getPresenters() - должен возвращать Presenter'ы экрана. View получает Presenter с помощью инъекции в поле;
* #getContentView() - (только для BaseActivityView) должен вернуть Id Layout’а этого экрана.
* #getScreenConfigurator() - получает конфигуратор чеез компонент провайде ComponentProvider.

**ScreenConfigurator** инкапсулирует всю логику работы с Dagger.
ScreenConfigurator должен содержать:
* Интерфейс наследник от ScreenComponent,
для которого следует указать View экрана как параметр типа.
Если на этом экране используются диалоги с возвращением результата,
то в этом компоненте следует также определить методы #inject() для каждого из диалогов.
В компоненте должен быть указан родительский компонент
(в большинстве случаев AppComponent) в ‘dependencies’ и
ActivityViewModule(FragmentViewModule) и другие модули,
необходимые для этого экрана в ‘modules’;
* Статический класс - Dagger модуль экрана (опционально),
который необходим передачи аргументов, с которыми стартовал экран,
и для простоты может расширять CustomScreenModule.

При наследовании от BasePresenter следует указать View экрана как параметр типа.

Для создания нового экрана предусмотрены шаблоны.
`ПКМ на пакете->New->Surf->Activity/Fragment todo

#### Кастомные вью

Для создания кастомных вью рекомендуется следовать рекомендациям описанным в
[здесь](https://docs.google.com/document/d/1Scu3QXgpVLNpTLOP6nwTnBNWXRQueMiHukfAip_ZLP0/edit#heading=h.ah2nz5eiite7).

Создание виджетов с презентером -> [здесь](../mvp-widget/README.md)

#### Диалоги
Используются диалоги поставляемые модулем mvp-dialog.

Подробная документация : [диалоги](../mvp-dialog/README.md)

#### Навигация

Навигация между экранами должна происходить только из слоя Presenter.

Для навигации по приложению предусмотрены сущности Navigator(поставляются модулями *core-ui, core-mvp*).
Navigator осуществляет навигацию в соответствии с переданным ему объектом Route.
Route, кроме определения, какой конкретно экран открывать может быть ответственен за:
-  упаковку данных в Intent (Bundle) для передачи аргументов в экран, диалог
-  распаковку данных из Intent (Bundle) переданных в экран, диалог
-  упаковку данных в Intent для передачи результата на предыдущий экран
-  распаковку данных результата выполнения экрана из Intent

Предусмотрены следующие навигаторы:
* ActivityNavigator
* DialogNavigator
* различные FragmentNavigator, которые создаются по мере надобности:
   * FragmentNavigator - обертка для навигации по фрагментам
   * TabFragmentNavigator - поддерживает стеки фрагментов на одном табе.

Каждый навигатор имеет набор базовых классов Route.

Передача параметров при старте экрана происходит через Route
и эти параметры получает презентер в конструктор также обернутые в Route.
Для упрощения этой передачи предусмотрен базовый класс для модуля экрана CustomScreenModule.

Если необходимо стартовать экран с последующим получением результата,
необходимо зарегистрировать обработчик этого события через
АctivityNavigator#observeActivityResult в методе BasePresenter#onLoad.

Подробная документация: [Навигация](../core-ui/README.md).


