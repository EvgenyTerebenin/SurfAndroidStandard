# UI слой
#### Структура пакетов

Так как используется многомодульная архитектура, то данный слой представлен несколькими модулями:
* app-injector - содержит конфигураторы экранов(Dagger)

* base-ui - включает базовые классы данного слоя для всех фич, а также переиспользуемые сущности,
которые нельзя выделить в отдельную фичу или же это не имеет смысла(Например конкретная кастомная вью без презентера и дополнительных сущностей)
Также включает в себя пакет util, который содержит в себе полезные сущности, хелперы, методы для работы с UI.
Может включать в себя пакет navigation для навигации между модулями.

* f-*name* - конкретный модуль фичи(см. [Многомодульность](arch.md))
Моджет быть разбит по более мелким пакетам - логическим кускам фичи(конкретным эрканам , относящимся к одной фиче).
Содержит классы Route, View, Presenter, ScreenModel, Controller, etc

Пакет ui содержит несколько пакетов:
* base - включает основные базовые классы для слоев View/Presenter; -> в base-ui
* screen - включает набор подпакетов для всех экранов приложения. К таким классам относятся: View, Presenter, ScreenConfigurator (app-injector), Adapter, ViewHolders, кастомные android.View, локальная модель экрана, и т.д. Некоторые классы могут быть сгруппированы по логическому признаку в отдельный пакет внутри пакета экрана (например Adapter и ViewHolders в подпакет list);
Некоторые пакеты экранов могут быть сгруппированы по логическому признаку для предотвращения разрастания пакета screen.
* common - включает переиспользуемые на разных экранах компоненты, относящиеся к слоям View/Presenter, сгруппированные в подпакеты (например common.widget содержит каcтомные android.View); -> чаще всего base-ui/ cf-module
* util - включает классы-утилиты для слоев View/Presenter. -> base-ui (если только не для конкретной фичи)


#### Иcпользование студийных модулей
Для построения ахитектуры UI слоя следует подключить в проект core-модули.
* [core-ui](../core-ui/README.md)

* [core-mvp](../core-mvp/README.md) или [core-mvp-bindings]()

* [core-app](../core-app/README.md)

todo опистать шаги построения экрана (mvp / binding ?)
от чего наследоваться, в каком случае ,
что использовать. Ссылки на док

##### Создание экрана
Для создания нового экрана требуется расширить 4 класса: BasePresenter, ScreenConfigurator,
один из базовых классов вью, один из базовых классов Route.
При наследовании от одной из базовых View следует имплементировать следующие методы:
* #getPresenters() - должен возвращать Presenter'ы экрана. View получает Presenter с помощью инъекции в поле;
* #getContentView() - (только для BaseActivityView) должен вернуть Id Layout’а этого экрана.

ScreenConfigurator инкапсулирует всю логику работы с Dagger.
ScreenConfigurator должен содержать:
* Интерфейс наследник от ScreenComponent,
для которого следует указать View экрана как параметр типа.
Если на этом экране используются диалоги с возвращением результата,
то в этом компоненте следует также определить методы #inject() для каждого из диалогов.
В компоненте должен быть указан родительский компонент
(в большинстве случаев AppComponent) в ‘dependencies’ и
ActtivityViewModule(FragmentViewModule) и другие модули,
необходимые для этого экрана в ‘modules’;
* Статический класс - Dagger модуль экрана (опционально),
который необходим передачи аргументов, с которыми стартовал экран,
и для простоты может расширять CustomScreenModule.
* реализацию метода #getName() - должен возвращать уникальное имя экрана;
* реализацию метода #getScreenComponent() - должен вернуть объект компонента этого экрана;

При наследовании от BasePresenter следует указать View экрана как параметр типа.
Для создания нового экрана предусмотрены шаблоны.


#### Загрузка основных данных
#### Кастомные вьюхи
#### Навигация
#### датафлоу

