# Построение архитектуры

### 1. Архитектура приложения
Приложение построено на упрощённой версии **СleanArcitecture**, адаптированной под мультимодульную архитектуру.

Основной причиной для выбора описанной архитектуры было стремление уменьшить сложность проекта. В частности использовались 2 основных принципа:

- Принцип единственной ответственности (разделение на слои, модули)
- Инкапсуляция (сокрытие реализации от остальных частей приложения)


*Приложение состоит из следующих основных слоев*:

* Domain - содержит сущности и логику предметной области.
* Interactor - содержит внутреннюю(бизнес) логику приложения. Этот слой предоставляет доступ к хранилищам данных и другим сервисам. Api этого слоя не должно зависеть от Android Framework и других библиотек. Слой Interactor состоит из модулей, каждый из которых имеет строго определенную ответственность. Детали реализации каждого модуля не должны быть доступны никаким другим частям приложения, кроме этого модуля. На этом уровне должно происходить трансформирование структур данных, используемых во внешних хранилищах, в модели слоя Domain. Бизнес логика должна быть максимально отделена от деталей реализации.
* Presenter - содержит логику экранов. В презентере происходят все манипуляции с данными, изменение данных внутри View недопустимо. Презентеры не должны содержать бизнес логику приложения.
* View - слой представления, отвечает за взаимодействие с пользователем. Вью не должна  содержать логику экрана, только логику отображения. Вью должна быть максимально пассивной.


Каждый последующий слой может зависеть только от предыдущего и от слоя Domain.
Каждый класс принадлежит только одному из вышеперечисленных слоев.


### 2. Многомодульность
и ее взаимосвязь со слоями.
Что такое f-, i-, cf- модули, как они взаимосвязаны друг с другом.
App-injector как единая точка входа и единственный модуль с даггером.
todo

### 3. Инъекция зависимостей
тех.док + ссылки на dagger-scope

*Инъекция зависимостей* реализована с помощью библиотеки **Dagger 2**.
Область видимости более высокого уровня расширяет область видимости более низкого уровня.

В приложении есть 2 основных вида Scope (области видимости):

* Scope приложения (аннотация @PerApplication) - предоставляет объекты, слоя Interactor. Эти объекты являются синглтонами.
* Scope активити (аннотация @PerActivity) - предоставляет обьекты, привязанные к жизненному циклу Активити (например RxBus). Этот Скоуп рамполагается между PerApplication и PerScreen. Не забывайте пробрасывать обьекты из PerAplication в PerScreen через AppComponent и ActivityComponent.
* Scope экрана (аннотация @PerScreen) - предоставляет объекты, привязанные к жизненному циклу экрана

@PerScreen может применяться для экранов, основанных как на Activity так и на Fragment.
Разрешается добавлять скоупы для собственных нужд, между уровнем приложения и уровнем экрана. Эти скоупы должны быть описаны в конце этого раздела.

Для каждого экрана создается свой dagger компонент, название компонента должно соответствовать следующему правилу: <название экрана>ScreenComponent.
Этот компонент находиться в app-injector, и регистрируется в Storage.
На экране компонент доступен через ComponentProvider.

Все объекты для удовлетворения зависимостей разделены на логически связанные dagger модули.

### 4. Шина сообщений

Шину сообщений использовать можно только для связывание 2-х презентеров в контексте одной активити. Для шины Предусмотрен класс RxBus. RxBus относится к скопу @PerActivity.

### 5. Асинхронные взаимодействия
Rx, i-модули

Для подавляющего количества асинхронных задач следует использовать RxJava.
Слой Presenter может взаимодействовать с асинхронными задачами только через Rx,
из-за специфической архитектуры слоев View / Presenter.
Поток, в котором будет выполняться асинхронная задача следует указывать
непосредственно перед подпиской на Observable.
Это необходимо для выполнения составных асинхронных задач в одном
потоке.

Для указания потока выполнения и потока подписки асинхронной
задачи,
обернутой в Observable присутствует класс SchedulersProvider,
предоставляющий доступ к Sheduler главного и рабочего потока.
Использование классов rx.Schedulers и AndroidSchedulers запрещено.
Эта абстракция была создана для возможности тестирования асинхронного
взаимодействия между модулями.

### 6. Логгирование
ссылка на [logger]()

Логгирование в logcat осуществляется с помощью класса Logger, который является
оберткой над библиотекой Timber. В обязательном порядке логгируются:
* Url запросов и статус ответов сервера
* NonFatalExceptions (состояния приложения, когда часть его функционала
неправильно отработала, но при этом приложение может продолжать работать)

Оставлять логи, которые не несут важной информации запрещено.
Для ожидаемых ошибок предусмотрен метод Logger.w(Throwable),
который логгирует только сообщение ошибки.
Не оставляем пустые обработчики ошибок rx потока.
Не пишем e.printStackTrace().

Для логгирования в Crashlytics предусмотрен класс RemoteLogger.
В RemoteLogger отправляются:
* Все логи Logger’a выше уровня VERBOSE
* Exceptions, которые логгируется через Logger#e(),
отправляются как NonFatalExceptions.(в том числе ошибки парсинга ответа сервера).
__Не забиваем крашлитикс ненужными NonFatal, для ожидаемых ошибок используем Logger.w()__
* События onPause и onResume экранов

?
Кроме того в RemoteLogger также устанавливаются id, имя и email пользователя при входе в аккаунт и очищаются при выходе.

Для отслеживания ANR применяется библиотека AnrWatchDog. При детектировании ANR соответствующий NonFatal отправляется в RemoteLogger.

